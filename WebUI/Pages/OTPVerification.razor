@page "/otp-verification"
@layout AuthLayout
@using System.Timers
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<div class="auth-container otp-container">
    <div class="otp-form-wrapper">
        <div class="otp-form-container">
            <!-- Icon -->
            <div class="otp-icon">
                @if (verificationType == "email")
                {
                    <i class="fas fa-envelope-open"></i>
                }
                else
                {
                    <i class="fas fa-mobile-alt"></i>
                }
            </div>

            <!-- Content -->
            <div class="otp-content">
                <h2 class="otp-title">Xác nhận tài khoản</h2>
                <p class="otp-description">
                    Mã OTP đã được gửi đến @verificationType: 
                    <span class="contact-info">@maskedContact</span>
                </p>

                <!-- OTP Input Form -->
                <form @onsubmit="HandleVerification" @onsubmit:preventDefault="true" class="otp-form">
                    <div class="otp-inputs" @ref="otpContainer">
                        @for (int i = 0; i < 6; i++)
                        {
                            var index = i; // Capture for lambda
                            <input type="text" 
                                   @key="@i"
                                   @ref="otpInputs[i]"
                                   @bind="otpDigits[i]"
                                   @oninput="@(async (e) => await OnOtpInput(e, index))"
                                   @onkeydown="@(async (e) => await OnOtpKeyDown(e, index))"
                                   @onpaste="@(async (e) => await OnOtpPaste(e, index))"
                                   class="otp-input @(GetOtpInputClass(i))"
                                   maxlength="1"
                                   inputmode="numeric"
                                   pattern="[0-9]" />
                        }
                    </div>

                    @if (isInvalid)
                    {
                        <div class="otp-error shake">
                            <i class="fas fa-exclamation-circle"></i>
                            Mã OTP không chính xác. Vui lòng thử lại.
                        </div>
                    }

                    @if (!string.IsNullOrEmpty(errorMessage))
                    {
                        <div class="otp-error">
                            <i class="fas fa-exclamation-circle"></i>
                            @errorMessage
                        </div>
                    }

                    <!-- Timer & Resend -->
                    <div class="otp-timer">
                        @if (timeLeft > 0)
                        {
                            <p class="timer-text">
                                Gửi lại mã sau <span class="countdown">@FormatTime(timeLeft)</span>
                            </p>
                        }
                        else
                        {
                            <button type="button" 
                                    class="resend-btn" 
                                    @onclick="ResendOtp"
                                    disabled="@isResending">
                                @if (isResending)
                                {
                                    <i class="fas fa-spinner fa-spin"></i>
                                    <span>Đang gửi...</span>
                                }
                                else
                                {
                                    <i class="fas fa-redo"></i>
                                    <span>Gửi lại mã OTP</span>
                                }
                            </button>
                        }
                    </div>

                    <!-- Verify Button -->
                    <button type="submit" 
                            class="btn-primary otp-verify-btn" 
                            disabled="@(isVerifying || !IsOtpComplete())">
                        @if (isVerifying)
                        {
                            <i class="fas fa-spinner fa-spin"></i>
                            <span>Đang xác nhận...</span>
                        }
                        else
                        {
                            <span>XÁC NHẬN</span>
                        }
                    </button>

                    <!-- Change Contact -->
                    <div class="otp-footer">
                        <a href="@GetChangeContactLink()" class="change-contact-link">
                            <i class="fas fa-edit"></i>
                            Thay đổi @(verificationType == "email" ? "email" : "số điện thoại")
                        </a>
                    </div>
                </form>
            </div>
        </div>

        <!-- Success Animation (Hidden by default) -->
        <div class="success-animation @(showSuccess ? "show" : "")" @ref="successElement">
            <div class="success-circle">
                <i class="fas fa-check"></i>
            </div>
            <h3>Xác nhận thành công!</h3>
            <p>Tài khoản của bạn đã được kích hoạt.</p>
        </div>
    </div>
</div>

@code {
    private ElementReference otpContainer;
    private ElementReference successElement;
    private ElementReference[] otpInputs = new ElementReference[6];
    private string[] otpDigits = new string[6];
    private Timer? countdownTimer;
    
    private string verificationType = "email";
    private string contact = "";
    private string maskedContact = "";
    private int timeLeft = 60; // seconds
    private bool isVerifying = false;
    private bool isResending = false;
    private bool isInvalid = false;
    private bool showSuccess = false;
    private string errorMessage = "";

    protected override async Task OnInitializedAsync()
    {
        // Get parameters from URL
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var queryString = uri.Query;
        
        // Simple query parameter parsing
        var query = new Dictionary<string, string>();
        if (!string.IsNullOrEmpty(queryString) && queryString.StartsWith("?"))
        {
            var pairs = queryString[1..].Split('&');
            foreach (var pair in pairs)
            {
                var keyValue = pair.Split('=');
                if (keyValue.Length == 2)
                {
                    query[keyValue[0]] = Uri.UnescapeDataString(keyValue[1]);
                }
            }
        }
        
        if (query.TryGetValue("email", out var email))
        {
            verificationType = "email";
            contact = email ?? "";
            maskedContact = MaskEmail(contact);
        }
        else if (query.TryGetValue("phone", out var phone))
        {
            verificationType = "phone";
            contact = phone ?? "";
            maskedContact = MaskPhone(contact);
        }
        else
        {
            // No valid parameters, redirect back
            Navigation.NavigateTo("/register");
            return;
        }

        StartCountdown();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("addAuthPageClass");
            
            // Auto-focus first input
            if (otpInputs[0].Id != null)
            {
                await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[0]);
            }
        }
    }

    private void StartCountdown()
    {
        timeLeft = 60;
        countdownTimer?.Dispose();
        countdownTimer = new Timer(1000);
        countdownTimer.Elapsed += OnTimerElapsed;
        countdownTimer.Start();
    }

    private async void OnTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        timeLeft--;
        if (timeLeft <= 0)
        {
            countdownTimer?.Stop();
        }
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnOtpInput(ChangeEventArgs e, int index)
    {
        var value = e.Value?.ToString() ?? "";
        
        // Only allow digits
        if (!string.IsNullOrEmpty(value) && !char.IsDigit(value[0]))
        {
            return;
        }

        otpDigits[index] = value;
        isInvalid = false; // Clear invalid state when user types

        // Auto-focus next input
        if (!string.IsNullOrEmpty(value) && index < 5)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[index + 1]);
        }

        // Auto-submit when all 6 digits are entered
        if (IsOtpComplete())
        {
            await Task.Delay(100); // Small delay for better UX
            await HandleVerification();
        }

        StateHasChanged();
    }

    private async Task OnOtpKeyDown(KeyboardEventArgs e, int index)
    {
        // Backspace handling
        if (e.Key == "Backspace")
        {
            if (string.IsNullOrEmpty(otpDigits[index]) && index > 0)
            {
                otpDigits[index - 1] = "";
                await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[index - 1]);
            }
            else
            {
                otpDigits[index] = "";
            }
            isInvalid = false;
            StateHasChanged();
        }
        // Arrow key navigation
        else if (e.Key == "ArrowLeft" && index > 0)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[index - 1]);
        }
        else if (e.Key == "ArrowRight" && index < 5)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[index + 1]);
        }
    }

    private async Task OnOtpPaste(ClipboardEventArgs e, int index)
    {
        // Handle paste event for OTP
        await JSRuntime.InvokeVoidAsync("handleOtpPaste", otpContainer, DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async Task SetOtpFromPaste(string otpText)
    {
        var digits = otpText.Where(char.IsDigit).Take(6).ToArray();
        for (int i = 0; i < Math.Min(digits.Length, 6); i++)
        {
            otpDigits[i] = digits[i].ToString();
        }
        
        // Focus last filled input or first empty input
        var lastIndex = Math.Min(digits.Length - 1, 5);
        if (lastIndex >= 0)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[lastIndex]);
        }

        isInvalid = false;
        StateHasChanged();

        // Auto-submit if complete
        if (IsOtpComplete())
        {
            await Task.Delay(100);
            await HandleVerification();
        }
    }

    private bool IsOtpComplete()
    {
        return otpDigits.All(d => !string.IsNullOrEmpty(d));
    }

    private string GetOtpInputClass(int index)
    {
        var classes = new List<string>();
        
        if (!string.IsNullOrEmpty(otpDigits[index]))
        {
            classes.Add("filled");
        }
        
        if (isInvalid)
        {
            classes.Add("invalid");
        }
        
        return string.Join(" ", classes);
    }

    private async Task HandleVerification()
    {
        if (!IsOtpComplete()) return;

        isVerifying = true;
        isInvalid = false;
        errorMessage = "";
        
        try
        {
            var otp = string.Join("", otpDigits);
            
            // Simulate API call
            await Task.Delay(1500);
            
            // Fake validation - accept "123456" as valid OTP
            if (otp == "123456")
            {
                // Success animation
                await ShowSuccessAnimation();
                
                // Redirect after animation
                await Task.Delay(2000);
                Navigation.NavigateTo("/login?verified=true");
            }
            else
            {
                // Invalid OTP - show error animation
                isInvalid = true;
                await JSRuntime.InvokeVoidAsync("addShakeAnimation", otpContainer);
                
                // Clear OTP inputs after error
                await Task.Delay(1500);
                for (int i = 0; i < 6; i++)
                {
                    otpDigits[i] = "";
                }
                
                // Focus first input
                await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[0]);
            }
        }
        catch (Exception)
        {
            errorMessage = "Đã có lỗi xảy ra. Vui lòng thử lại sau.";
        }
        finally
        {
            isVerifying = false;
            StateHasChanged();
        }
    }

    private async Task ShowSuccessAnimation()
    {
        showSuccess = true;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("playSuccessAnimation", successElement);
    }

    private async Task ResendOtp()
    {
        isResending = true;
        errorMessage = "";
        
        try
        {
            // Simulate API call
            await Task.Delay(1000);
            
            // Restart countdown
            StartCountdown();
            
            // Clear current OTP
            for (int i = 0; i < 6; i++)
            {
                otpDigits[i] = "";
            }
            
            await JSRuntime.InvokeVoidAsync("focusElement", otpInputs[0]);
        }
        catch (Exception)
        {
            errorMessage = "Không thể gửi lại mã OTP. Vui lòng thử lại.";
        }
        finally
        {
            isResending = false;
            StateHasChanged();
        }
    }

    private string FormatTime(int seconds)
    {
        return $"{seconds / 60:00}:{seconds % 60:00}";
    }

    private string MaskEmail(string email)
    {
        if (string.IsNullOrEmpty(email)) return "";
        
        var parts = email.Split('@');
        if (parts.Length != 2) return email;
        
        var username = parts[0];
        var domain = parts[1];
        
        if (username.Length <= 2)
        {
            return $"{username}@{domain}";
        }
        
        var masked = $"{username[0]}{'*' * (username.Length - 2)}{username[^1]}@{domain}";
        return masked;
    }

    private string MaskPhone(string phone)
    {
        if (string.IsNullOrEmpty(phone) || phone.Length < 4) return phone;
        
        var visibleCount = Math.Min(3, phone.Length / 2);
        var hiddenCount = phone.Length - visibleCount * 2;
        
        return $"{phone[..visibleCount]}{'*' * hiddenCount}{phone[^visibleCount..]}";
    }

    private string GetChangeContactLink()
    {
        return verificationType == "email" ? "/register" : "/register";
    }

    public void Dispose()
    {
        countdownTimer?.Dispose();
    }
}